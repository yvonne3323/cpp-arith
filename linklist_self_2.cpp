//主要是一些问题
// 创建新结点是有必要的
        // 习惯性带入顺序表中一次性创建多个位置的思想
        // 与顺序表的判断不太一样：顺序表主要在函数就会判断是否合法，而链表是在主函数中判断
        // 这主要体现bool类型的使用，顺序表主要使用void类型
        // 弊端在于如果是不小心输入错误，不像顺序表可以重新输入，而是表示从头来过，但也方便退出
                               // 创建我补充了while
                               // cout << "删除的元素为：" << e << endl;//补充了删除的元素是什么，删除错误后果：删除的元素为：0(更改)
//     for (i = 0; i < n; i++)
//     {
//         p = new LNode;
//         cin >> p->data;
//         p->next = L->next;
//         L->next = p;
//     }
//     int j = 0;
//     LNode *p = L->next;
//     while (p != NULL && j < i)//如果j<i,则p指向下一个结点
//     {
//         j++;
//         p = p->next;
//     }
//     if (p == NULL)
//         return false;
//     e = p->data;
//     return true;
// }